\section{Control Methods}%
\label{sec:control_methods}
This section elaborates why control is required and which control methods are best suitable for various scenarios. During this thesis the effect of the robot interacting with objects is captured by system models. In addition to predicting output with system models, control methods leverage the prediction that system models provide to perform actions such a driving and pushing. A first requirement for a controller is that it should yield a stable closed-loop control because that gurantees converging toward a setpoint, then additional requirements are desired such as a low prediction error, low tracking error and low final placement error. Now the 2 implemented control methods are discussed.\bs

\paragraph{\acs{MPC} Control}

The \ac{MPC} controller can be tuned in many ways, for example, to steer the system to the goal aggressively or calmly by adjusting the maximum input and by putting a penalty on rapid input changes. The weights inside its internal objective function can be adjusted during execution time allowing to shift the controller focus from rapid movement to avoiding obstacle regions or converging to a target set point. The best feasible input is found every time step by optimising the objective function whilst respecting constraints. Solving an optimisation function to find the best feasible input generally yields robust control. It is however required that the system model is \ac{LTI}. System models for driving the robot can be estimated with \ac{LTI} models without compromising on model accuracy.
\todo[inline]{Document the \ac{MPC} method}

\paragraph{\acs{MPPI} Control}

A main advantage \ac{MPPI} has over \ac{MPC} control is that it is compatible with nonlinear system models. Whilst drive applications can be accurately estimated by linear models, push applications are harder to estimate with a linear model. Thus \ac{MPPI} is selected mainly for push applications.
\todo[inline]{Document the \ac{MPPI} method}\bs



Not all control methods are compatible with every system identification method, the following table conveniently displays which control methods implemented are compabible with the system identification methods used.\bs

\begin{figure}[H]
\begin{minipage}{0.5\linewidth}
\begin{table}[H]
\centering
\begin{tabular}[t]{l c c}
  control sys.~iden. & \ac{PEM} & \ac{IPEM} \\
  \toprule
  \ac{MPC} & \cmark& \cmark\\
  \ac{MPPI} & \cmark& \cmark\\
\end{tabular}
\caption{Drive Control}%
\label{table:compatible_modules_drive}
\end{table}
\end{minipage}
\begin{minipage}{0.5\linewidth}
\begin{table}[H]
\centering
\begin{tabular}[t]{l c c }
  control sys.~iden. & \ac{PEM} & \acs{LSTM}\\
  \toprule
  \ac{MPC} & \cmark& \xmark\\
  \ac{MPPI} & \cmark& \cmark\\
\end{tabular}
\caption{Push Control}%
\label{table:compatible_modules_push}
\end{table}
\end{minipage}
\caption{Compatibility between control and system identification methods for drive and push actions.}%
\label{table:compatible_modules}
\end{figure}

\todo[inline]{Update the table above to the sys. iden. that are implemented OR explain why they are not implemented at all}

It is worth mentioning that the goal of this thesis is not to find an best optimal controller. The goal is to gradually over time choose control methods in combination with system models that result in better performance, the performance is measured with various metrics to which \cref{subsec:edge_metrics} is dedicated. 

