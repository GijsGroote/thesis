\subsection{The Search and the Execution loop}%
\label{subsec:two_loops}
Now that \ac{hgraph} is defined let's find out how it reacts to various behaviour. The reaction of the \ac{hgraph} can be visualized in a flowchart of the \ac{hgraph} provided in \cref{tikz:flowchart_hgraph}. In \cref{tikz:flowchart_hgraph} two loops can be identified, clarified in \Cref{fig:two_loops_identified}. In the search, loop hypotheses are formed and the execution loop tests the hypothesis.\bs

\begin{figure}[H]
    \centering
    \includegraphics[width=5cm]{figures/two_loops_identified}
    \caption{The search and execution loop.}%
    \label{fig:two_loops_identified}
\end{figure}
\todo[inline]{Update figure above, professionalise arrows}

While the \ac{hgraph} resides in the search loop, hypotheses are formed. Forming a hypothesis, generating edges, nodes and progressing their status as described in \cref{tikz:status_identification_edge,tikz:status_action_edge} respectively. The \ac{hgraph} operates synchronously, thus at any point in time, the \ac{hgraph} resides in a single block within \cref{tikz:flowchart_hgraph}. The result is that the robots cannot operate whilst the \ac{hgraph} resides in the search loop, and during execution, no hypothesis can be formed or updated. Assumption~\ref{assumption:closed_world} guarantees that the robot environment does not change causing existing hypotheses to be outdated.\bs

While the \ac{hgraph} resides in the execution loop, \textit{an edge is being executed}. The phrase \quotes{an edge is being executed} seems odd at first because every aspect of closed-loop control resides in an edge, edges can be executed. Recall that nodes in the \ac{hgraph} represent objects in a state, and edges represent actions. Now a flowchart of the behaviour of the \ac{hgraph} is presented.\bs

\input{mainmatter/hypothesis_graph/hgraph_tikz_figure}

\Cref{table:explainer_hgraph_figures_nodes} provides important information that does not fit on the flowchart above.


\begin{table}[H]
\centering
\rowcolors{2}{white}{my_light_blue}
\begin{tabular}[t]{>{\raggedright}p{3.5cm}>{\raggedright\arraybackslash}p{10.5cm}}
  \textbf{Node name} & \textbf{Description of actions taken}\\\toprule
  Task Finished & log all metrics for the \ac{hgraph}, then deconstruct \ac{hgraph}.\\
  Create Start and\newline Target Nodes & Generate a robot node and the start and target nodes for every subtask in the task.\\
Update Current Subtask & Select an unfinished subtask or update current subtask. Use a backward search, eleborated in \cref{subsec:connecting_nodes} so select and update the \textit{current\_start\_node} and \textit{current\_target\_node}. When all subtask have been addressed, conclude task is finished. \\
Estimate Path\newline Existence & Check if a path exists between \textit{current\_start\_node} and \textit{current\_target\_node} whilst assuming that the object is holonomic.\\
Add Node to\newline Drive to Object & Add a node before the \textit{current\_target\_node}.\\
Unfeasible Node & Update node's status to unfeasible because is can not be completed, log failed Edge.\\
Knowledge Available& Query the \ac{kgraph} for action suggestion to connect \textit{current\_target\_node} to \textit{current\_target\_node}\\
Knowledge Usable& Check if a suggested action is not on the blacklist.\\
Object Movable & Check if object is classified as movable\\
Robot Close to Object& Check if the object is inside directly reachable free space of the robot \\
Generate Random\newline Action& Randomly sample a controller with a compatible system identification method that is not on the blacklist. \\
All Possible Actions Failed & Every possible action is on the blacklist for the \textit{current\_target\_node}, update \textit{current\_target\_node} status to failed.\\
Add Drive System Identification Edge & Adds identification edge between a newly generated node and the drive action edge source node. \\
Model Available& Checks if the drive action edge contains a system model. \\
Action Type& Checks the action type. \\
Model Available& Checkif the push action edge containts a system model. \\
Add Push System\newline Identification Edge& Adds identification edge compatible with push action edge. \\
Motion Planning& Search a path for the \textit{current\_edge}, detect blocking objects. \\
Add Node to Free Path & Search closeby pose for object to free path. Create node to push object toward that pose. \\
Manipulation Planning & Search a path for the \textit{current\_edge}, detect blocking objects.\\
Add Node to Drive\newline to Push Pose& Create node to drive toward push pose, add before action edge. \\
Robot Close to\newline Push Pose & Check if the robot is overlapping with the best push position. \\
Path to Target& Is there a path from robot to target node in the \ac{hgraph}, then set first edge to \textit{current\_edge} otherwise update subtask.\\
First Action Planned&  Check if motion/manipulation planning was performed. \\
Execute& Execute the \textit{current\_edge}, update \ac{hgraph} after completion, log failed hypothesis if a fault is detected. \\
Subtask Succesfully\newline Completed& Log hypothesis metrics. \\
Target Node Reached& Check if the target node is reached.\\
\end{tabular}
\caption{Eleborated description of blocks in the \cref{pseudocode:proposed_rrt_star}, ordered in this table with respect the top to bottom, left to right it \cref{pseudocode:proposed_rrt_star}.}%
\label{table:explainer_hgraph_figures_nodes}
\end{table}

After initialising the \ac{hgraph} with a task, there is only a single access point toward the \ac{hgraph}. A function \textit{respond(observation)} that returns control input toward the robot. As argument function \textit{respond(observation)} takes an observation of the environment, such an observation contains measurements of every object's latest measured state. Recall that the perfect-sensor assumption, assumption~\ref{assumption:perfect_object_sensor} provides access to the exact states of every object.\bs
\todo[inline]{it is not clear to the reader that the text above only focusses on a single subtask AKA no global optimum for the task is sought}

\todo[inline]{Visualise this in hgraph: adding an edge for a drive action including sys iden. use "backward search"}
 A hypothesis is formed when the robot node is connected through a set of successive edges to the subtasks target node.
\todo[inline]{visualise this in hgraph: Executing a drive action}
\todo[inline]{Visualise this: adding an edge for a push action including sys iden.}
\todo[inline]{visualise this in hgraph: Executing a push action}
\todo[inline]{emphasise recursiveness of the hgraph, thus want to move box A, but B is in the way, move box B first, but box C is in the way, move box C first becomes: move(C) -> move(B) -> move(A)}

\todo[inline]{introduce the blacklist: a set of edges that cannot be added to a node because they failed in the past. The blacklist prevents regenerating edges which already failed in the past}

\todo[inline]{section about fault/monitoring metrics, that can halt and fail an executing edge}

What by now hopefully became clear to the reader is that the \ac{hgraph} autonomously searches for hypotheses to solve the task, one subtask at a time. The \ac{hgraph} switches between the search and execution loop. Switching from the search loop toward the execution loop when a hypothesis is found, and switching back when a hypothesis is completed or an action failed to complete.\bs

The limited number of possible edges (every combination of a system identification method with a compatible control method) guarantees that the robot tries to connect 2 nodes, but concludes that it cannot reach a node if all possible edges have failed. Eventually running out of nodes to connect and conclude that a subtask cannot be completed.\bs

In the next section, the edges that are executed will be reviewed and stored in a knowledge base. The knowledge base will suggest edges when faced with similar nodes to connect.
