\section{Hypothesis Graph}%
\label{sec:hgraph}
The \acf{hgraph} consists of a set of nodes and edges. Where the node correspond to an object at a configuration, and the edges correspond to actions. As a whole the \ac{hgraph} represents a search (or planned search) in the composite configuration space. The \ac{halgorithm} creates and updates nodes and edges in the \ac{hgraph} and is discussed in \Cref{subsec:halgorithm}. A search in the composite configuration space is avoided because an edge only operates in a single mode of dynamics, in the scope of this thesis a driving mode or pushing mode. The \ac{hgraph} is created specifically for a task with a single start and a single target node for every subtask in the task. When the \ac{halgorithm} halts and the task is completed, the \ac{hgraph} is no longer needed and is discarded.\bs

The \ac{halgorithm} with the \ac{hgraph} have a familiar structure compared to some recent literature~\cite{ellis_navigation_2022,wang_affordancebased_2020}. An important distinction is that the proposed framework in this thesis aims to combine the 3 topics: learning object dynamics, solving \ac{NAMO} problems and nonprehensile pushing. Recent literature is able to only combine one or two topics of the three.\bs

In the upcoming section the \ac{hgraph} is defined and discussed in \Cref{subsec:hgraph_definition}. The \ac{halgorithm} is then discussed and in \Cref{subsec:halgorithm}, where an explanation is provided on how the \ac{halgorithm} searches for a solution in the composite configuration space. The section is concluded with an extensive example.\bs

\input{mainmatter/hypothesis_graph/definition}
\input{mainmatter/hypothesis_graph/halgorithm}
\input{mainmatter/hypothesis_graph/examples}

What by now hopefully became clear to the reader is that the \ac{halgorithm} autonomously searches for hypotheses in the \ac{hgraph} to solve a task, one subtask at a time. The \ac{halgorithm} switches between the search and execution loop. Switching from the search loop toward the execution loop when a hypothesis is found, and switching back when a hypothesis is completed or an fault or failure occurred.\bs

The limited number of possible edge parameterization (every combination of a system identification method with a compatible control method) guarantees that the robot tries to complete a subtask, but concludes that it is unable to complete a subtask if all possible edges have failed.\bs

Recall the 3 topics (learning object dynamics, the \ac{NAMO} problem and nonprehensile push manipulation) that this thesis proposes to combine. The \ac{halgorithm} can solve \ac{NAMO} problems because the robot can drive toward target positions even if reaching such a position requires objects to be moved first. The \ac{halgorithm} can push objects to target positions by first identifying a system model and then pushing the object toward its target position. The proposed algorithm learns to classify objects by updating objects class from unknown to movable or obstacle. The system model that system identification yields is however of short use, it is only given to the corresponding action edge. In the next section, the edges that are executed will be reviewed and stored in a knowledge base. The knowledge base will suggest a parameterization for an edge when faced with similar nodes to connect. 
